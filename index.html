<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CDN Flow Diagram - Professional</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:100vh;
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
  font-family:system-ui, -apple-system, sans-serif;
  overflow:hidden
}

.controls{
  position:fixed;
  top:20px;
  right:20px;
  z-index:10;
  background:rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(10px);
  padding:12px 20px;
  border-radius:12px;
  box-shadow:0 8px 32px rgba(0,0,0,0.1);
  display:flex;
  gap:15px;
  align-items:center;
  border:1px solid rgba(255,255,255,0.5);
  transition: opacity 0.3s;
}

.controls label{
  display:flex;
  align-items:center;
  gap:8px;
  cursor:pointer;
  font-size:14px;
  font-weight:500;
  color:#333;
  user-select:none;
}

input[type="range"] {
  -webkit-appearance: none;
  width: 100px;
  height: 4px;
  background: #e0e0e0;
  border-radius: 2px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #007bff;
  border-radius: 50%;
  cursor: pointer;
  transition: transform 0.1s;
}

input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}

#zoomValue {
  font-size: 12px;
  color: #666;
  min-width: 45px;
  text-align: right;
}

@media(max-width:768px){
  .controls{display:none}
  #diagram-container{width:100vw;height:100vh;overflow:auto}
  #diagram{transform:none!important}
  img{max-width:none;max-height:none;width:auto;height:auto}
}

#diagram-container{
  width:90vw;
  height:90vh;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
  position:relative;
  /* Glassmorphism border */
  border-radius:16px;
  box-shadow:0 20px 50px rgba(0,0,0,0.05);
}

#diagram{
  /* Use will-change for smoother GPU animations */
  will-change: transform;
  /* Cubic-bezier for a premium feel */
  transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
              transform-origin 0.1s ease-out;
  transform-origin:center;
  max-width:100%;
  max-height:100%;
  padding: 20px;
}

img{
  max-width:100%;
  max-height:100%;
  display:block;
  /* Soft shadow for the diagram itself */
  box-shadow:0 10px 30px rgba(0,0,0,0.15);
  border-radius:8px;
  background: white;
}
</style>
</head>
<body>
<div class="controls">
  <label>
    <input type="checkbox" id="zoomToggle"> Zoom on Hover
  </label>
  <input type="range" id="zoomLevel" min="200" max="800" value="200" step="50" disabled>
  <span id="zoomValue">200%</span>
</div>

<div id="diagram-container">
  <div id="diagram">
    <img id="svgImage" src="" alt="SVG Diagram">
  </div>
</div>

<script>
function getProjectKeyFromHash() {
  const raw = (window.location.hash || '').replace(/^#/, '').trim();
  if (!raw) return 'cdn-public';
  // Keep this strict to avoid path traversal and surprising fetches.
  if (/^[a-z0-9_-]+$/i.test(raw)) return raw;
  return 'cdn-public';
}

function resetZoomVisualState() {
  const diagram = document.getElementById('diagram');
  if (!diagram) return;
  diagram.style.transform = 'scale(1)';
  diagram.style.transformOrigin = 'center center';
}

async function loadSVG() {
  const svgImage = document.getElementById('svgImage');
  const path = getProjectKeyFromHash();

  svgImage.alt = 'Loading SVG diagram…';
  svgImage.setAttribute('aria-busy', 'true');
  svgImage.removeAttribute('aria-label');
  // Avoid showing a stale image while switching.
  svgImage.removeAttribute('src');

  resetZoomVisualState();

  try {
    const resp = await fetch('svgs.json', { cache: 'no-store' });
    if (!resp.ok) throw new Error(`Failed to load svgs.json (${resp.status})`);
    const data = await resp.json();
    const project = data?.projects?.[path];

    if (!project) {
      svgImage.alt = `No SVG found for “${path}”.`;
      svgImage.setAttribute('aria-busy', 'false');
      return;
    }

    svgImage.onload = () => {
      svgImage.alt = `SVG diagram: ${path}`;
      svgImage.setAttribute('aria-busy', 'false');
      resetZoomVisualState();
    };
    svgImage.onerror = () => {
      svgImage.alt = `Failed to load SVG for “${path}”.`;
      svgImage.setAttribute('aria-busy', 'false');
      svgImage.removeAttribute('src');
      resetZoomVisualState();
    };

    svgImage.src = `${path}/${project}`;
  } catch (err) {
    console.error(err);
    svgImage.alt = 'Failed to load SVG index.';
    svgImage.setAttribute('aria-busy', 'false');
  }
}

loadSVG();
window.addEventListener('hashchange', loadSVG);

if(window.innerWidth > 768) {
  const diagram = document.getElementById('diagram');
  const container = document.getElementById('diagram-container');
  const toggle = document.getElementById('zoomToggle');
  const zoomLevel = document.getElementById('zoomLevel');
  const zoomValue = document.getElementById('zoomValue');
  
  let zoomEnabled = false;
  let zoom = 2;
  // State variable to track if we are currently zooming (to avoid conflicts)
  let isHovering = false;

  // Throttle mousemove-driven updates to once per animation frame.
  let pendingFrame = 0;
  let lastOriginX = 50;
  let lastOriginY = 50;
  const baseTransition = getComputedStyle(diagram).transition;

  toggle.addEventListener('change', (e) => {
    zoomEnabled = e.target.checked;
    zoomLevel.disabled = !zoomEnabled;
    
    // Visual feedback for the diagram container
    if(zoomEnabled) {
      diagram.style.cursor = 'crosshair';
    } else {
      isHovering = false;
      if (pendingFrame) {
        cancelAnimationFrame(pendingFrame);
        pendingFrame = 0;
      }
      diagram.style.cursor = 'default';
      diagram.style.transition = baseTransition;
      diagram.style.transform = 'scale(1)';
      diagram.style.transformOrigin = 'center center';
    }
  });

  zoomLevel.addEventListener('input', (e) => {
    zoom = e.target.value / 100;
    zoomValue.textContent = e.target.value + '%';
    // Optional: If already hovering, update immediately
    if(isHovering) {
        diagram.style.transform = `scale(${zoom})`;
    }
  });

  container.addEventListener('mouseenter', () => {
    if (!zoomEnabled) return;
    isHovering = true;
    // Disable transitions while actively tracking pointer to avoid animation churn.
    diagram.style.transition = 'none';
  });

  container.addEventListener('mousemove', (e) => {
    if (!zoomEnabled) return;

    const rect = container.getBoundingClientRect();
    lastOriginX = ((e.clientX - rect.left) / rect.width) * 100;
    lastOriginY = ((e.clientY - rect.top) / rect.height) * 100;

    if (pendingFrame) return;
    pendingFrame = requestAnimationFrame(() => {
      pendingFrame = 0;
      if (!zoomEnabled) return;
      diagram.style.transformOrigin = `${lastOriginX}% ${lastOriginY}%`;
      diagram.style.transform = `scale(${zoom})`;
    });
  });

  container.addEventListener('mouseleave', () => {
    if (zoomEnabled) {
      isHovering = false;
      if (pendingFrame) {
        cancelAnimationFrame(pendingFrame);
        pendingFrame = 0;
      }
      diagram.style.transform = 'scale(1)';
      // Reset origin smoothly to center, or leave it for next entry? 
      // Resetting to center is usually safer to avoid jumps on re-entry
      diagram.style.transformOrigin = 'center center';
      // Restore transitions for the snap-back animation.
      diagram.style.transition = baseTransition;
    }
  });
}
</script>
</body>
</html>